{"./":{"url":"./","title":"前言","keywords":"","body":"为懒人准备的 webpack 模版，可以直接用于生产。这里单纯只做 webpack 构建、打包、代码的组织等，关于 React、Vue 等配置并不复杂，可以在需要时添加。随着 webpack 版本的迭代，会将最新的特性加入，持续更新...... 有空就写一点 ~,~ 源码：https://github.com/eleven-net-cn/webpack-template 版本 webpack 4 + babel 7 powered by GitbookLast modified time： 2021-04-23 15:03:41 "},"content/entry.html":{"url":"content/entry.html","title":"自动扫描入口 js、HTML 模版","keywords":"","body":" 正常如果有多个入口，需要在 entry 中，以对象形式将所有入口都配置一遍，html 模版目录也需要 new 很多个 HtmlWebpackPlugin 来配置对应的页面模版，是否可以自动扫描? 无论多少个入口，只管新建，而不用管理入口配置？可以的！ 安装 node 模块 glob ( 扫描文件就靠它了 ) yarn add glob -D const glob = require('glob') 自动扫描获取入口文件、html 模版（统一放在 utils.js 文件里） const fs = require('fs') const path = require('path') const glob = require('glob') const appDirectory = fs.realpathSync(process.cwd()) /** * 获取文件 * @param {String} filesPath 文件目录 * @returns {Object} 文件集合(文件名: 文件路径) */ const getFiles = filesPath => { let files = glob.sync(filesPath) let obj = {} let filePath, basename, extname for (let i = 0; i { let entry = {} for (let name in entries) { entry[name] = entries[name] } return entry } webpack 打包入口 module.exports = { entry: utils.getEntries(), } html 模版自动引入打包资源（区分 dev 和 prod 环境，配置不同，同样抽离到 utils.js 文件更好一些） const HtmlWebpackPlugin = require('html-webpack-plugin') /** * 生成webpack.config.dev.js的plugins下new HtmlWebpackPlugin()配置 * @returns {Array} new HtmlWebpackPlugin()列表 */ const getHtmlWebpackPluginsDev = () => { let htmlWebpackPlugins = [] let setting = null for (let name in templates) { setting = { filename: `${name}.html`, template: templates[name], inject: false, // js插入的位置，true/'head'/'body'/false } // (仅)有入口的模版自动引入资源 if (name in getEntries()) { setting.chunks = [name] setting.inject = true } htmlWebpackPlugins.push(new HtmlWebpackPlugin(setting)) setting = null } return htmlWebpackPlugins } /** * 生成webpack.config.prod.js的plugins下new HtmlWebpackPlugin()配置 * @returns {Array} new HtmlWebpackPlugin()列表 */ const getHtmlWebpackPluginsProd = () => { let htmlWebpackPlugins = [] let setting = null for (let name in templates) { setting = { filename: `${name}.html`, template: templates[name], minify: { removeComments: true, collapseWhitespace: true, removeRedundantAttributes: true, useShortDoctype: true, removeEmptyAttributes: true, removeStyleLinkTypeAttributes: true, keepClosingSlash: true, minifyJS: true, minifyCSS: true, minifyURLs: true, }, inject: false, // js插入的位置，true/'head'/'body'/false } // (仅)有入口的模版自动引入资源 if (name in getEntries()) { setting.chunks = ['manifest', 'vendor', 'common', name] setting.inject = true } htmlWebpackPlugins.push(new HtmlWebpackPlugin(setting)) setting = null } return htmlWebpackPlugins } 将 html-webpack-plugin 解构放到 plugins 里 const utils = require('./utils') ... plugins: { // dev ...utils.getHtmlWebpackPluginsDev(), }, ... ... plugins: { // build ...utils.getHtmlWebpackPluginsProd(), }, ... 完整的 utils.js powered by GitbookLast modified time： 2021-04-23 15:03:41 "},"content/babel/":{"url":"content/babel/","title":"Babel 7 转码","keywords":"","body":"Babel 7 转码 这是最新的 babel 配置，和网上的诸多教程可能有不同，可以自行测试验证有效性。 基础依赖包 yarn add babel-loader @babel/core -D 从 babel7 开始，所有的官方插件和主要模块，都放在了 @babel 的命名空间下。从而可以避免在 npm 仓库中 babel 相关名称被抢注的问题。 在 package.json 同级添加.babelrc 配置文件，先空着。 { \"presets\": [], // 预设 \"plugins\": [] // 插件 } package.json 文件可以声明需要支持到的浏览器版本 package.json 中声明的 browserslist 可以影响到 babel、postcss，babel 是优先读取.babelrc 文件中@babel/preset-env 的 targets 属性，未定义会读取 package.json 中的 browserslist。为了统一，在 package.json 中定义。 package.json 中定义（推荐） \"browserslist\": [ \"> 1%\", \"last 2 versions\", \"not ie 更多定义格式请查看：browserslist .babelrc 中定义（不推荐） { \"presets\": [ [ \"@babel/preset-env\", { \"targets\": { \"chrome\": \"58\", \"ie\": \"11\" } } ] ] } powered by GitbookLast modified time： 2021-04-23 15:03:41 "},"content/babel/preset-env.html":{"url":"content/babel/preset-env.html","title":"@babel/preset-env","keywords":"","body":"基本的语法转换，需要添加预设@babel/preset-env 安装依赖包 yarn add @babel/preset-env -D 添加配置 { \"presets\": [ [ \"@babel/preset-env\", { \"modules\": false, // 对ES6的模块文件不做转化，以便使用tree shaking、sideEffects等 } ] ], \"plugins\": [] } Babel 默认只转换新的 JavaScript 句法（syntax），而不转换新的 API，比如 Iterator、Generator、Set、Maps、Proxy、Reflect、Symbol、Promise 等全局对象，以及一些定义在全局对象上的方法（比如 Object.assign）都不会转码。转译新的 API，需要借助polyfill方案去解决，使用@babel/polyfill或@babel/plugin-transform-runtime，二选一即可。 powered by GitbookLast modified time： 2021-04-23 15:03:41 "},"content/babel/polyfill.html":{"url":"content/babel/polyfill.html","title":"@babel/polyfill","keywords":"","body":"@babel/polyfill 本质上@babel/polyfill是core-js库的别名，随着core-js@3的更新，@babel/polyfill无法从2过渡到3，所以@babel/polyfill已经被放弃，请查看corejs 3 的更新。 安装依赖包： yarn add @babel/polyfill .babelrc 文件写上配置，@babel/polyfill 不用写入配置，会根据useBuiltIns参数去决定如何被调用。 { \"presets\": [ [ \"@babel/preset-env\", { \"useBuiltIns\": \"entry\", \"modules\": false, \"corejs\": 2, // 新版本的@babel/polyfill包含了core-js@2和core-js@3版本，所以需要声明版本，否则webpack运行时会报warning，此处暂时使用core-js@2版本（末尾会附上@core-js@3怎么用） } ] ] } 配置参数 modules，\"amd\" | \"umd\" | \"systemjs\" | \"commonjs\" | \"cjs\" | \"auto\" | false，默认值是 auto。用来转换 ES6 的模块语法。如果使用 false，将不会对文件的模块语法进行转化。如果要使用 webpack 中的一些新特性，比如 tree shaking 和 sideEffects，就需要设置为 false，对 ES6 的模块文件不做转化，因为这些特性只对 ES6 的模块有效。 useBuiltIns，\"usage\" | \"entry\" | false，默认值是 false。 false：需要在 js 代码第一行主动 import '@babel/polyfill'，会将@babel/polyfill 整个包全部导入。（不推荐，能覆盖到所有 API 的转译，但体积最大） entry：需要在 js 代码第一行主动 import '@babel/polyfill'，会将 browserslist 环境不支持的所有垫片都导入。（能够覆盖到‘hello‘.includes(‘h‘)这种句法，足够安全且代码体积不是特别大） usage：项目里不用主动 import，会自动将代码里已使用到的、且 browserslist 环境不支持的垫片导入。（但是检测不到‘hello‘.includes(‘h‘)这种句法，对这类原型链上的句法问题不会做转译，书写代码需注意） targets，用来配置需要支持的的环境，不仅支持浏览器，还支持 node。如果没有配置 targets 选项，就会读取项目中的 browserslist 配置项。 loose，默认值是 false，如果 preset-env 中包含的 plugin 支持 loose 的设置，那么可以通过这个字段来做统一的设置。 powered by GitbookLast modified time： 2021-04-23 15:03:41 "},"content/babel/transform-runtime.html":{"url":"content/babel/transform-runtime.html","title":"@babel/plugin-transform-runtime","keywords":"","body":"@babel/plugin-transform-runtime 安装依赖包 yarn add @babel/plugin-transform-runtime -D 如果配置参数 corejs 未设置或为 false，需安装依赖@babel/runtime（这部分代码会被抽离并打包到应用 js 里，所以可以安装在 dependencies 里），仅对 es6 语法转译，而不对新 API 转译。 yarn add @babel/runtime 如果配置参数 corejs 设置为 2，需安装依赖@babel/runtime-corejs2（同上，推荐安装在 dependencies 里。），对语法、新 API 都转译。 yarn add @babel/runtime-corejs2 推荐使用corejs:2，但是，检测不到‘hello‘.includes(‘h‘)这种句法，所以存在一定隐患，书写代码时需注意。 @babel/runtime和@babel/runtime-corejs2这两个库唯一的区别是：corejs2 这个库增加了对 core-js（用来对 ES6 各个语法 polyfill 的库）这个库的依赖，所以在 corejs 为 false 的情况下，只能做语法的转换，并不能 polyfill 任何新 API。 .babelrc 文件写上配置 { \"presets\": [ [ \"@babel/preset-env\", { \"modules\": false } ] ], \"plugins\": [ [ \"@babel/plugin-transform-runtime\", { \"corejs\": 2 // 推荐 } ] ] } 配置参数 corejs，默认值是 false，只对语法进行转换，不对新 API 进行处理；当设置为 2 的时候，需要安装@babel/runtime-corejs2，这时会对 api 进行处理。 helpers，默认值是 true，用来开启是否使用 helper 函数来重写语法转换的函数。 useESModules，默认值是 false，是否对文件使用 ES 的模块语法，使用 ES 的模块语法可以减少文件的大小。 powered by GitbookLast modified time： 2021-04-23 15:03:41 "},"content/babel/polyfill-or-runtime.html":{"url":"content/babel/polyfill-or-runtime.html","title":"polyfill 方案的对比","keywords":"","body":"@babel/polyfill 还是 @babel/plugin-transform-runtime ？ @babel/preset-env + @babel/polyfill可以转译语法、新 API，但存在污染全局问题； @babel/preset-env + @babel/plugin-transform-runtime + @babel/runtime-corejs2，可按需导入，转译语法、新 API，且避免全局污染（babel7 中@babel/polyfill 是@babel/runtime-corejs2 的别名），但是检测不到‘hello‘.includes(‘h‘)这种句法； @babel/polyfill 和@babel/runtime-corejs2 都使用了 core-js(v2)这个库来进行 api 的处理。core-js(v2)这个库有两个核心的文件夹，分别是 library 和 modules。@babel/runtime-corejs2 使用 library 这个文件夹，@babel/polyfill 使用 modules 这个文件夹。 library 使用 helper 的方式，局部实现某个 api，不会污染全局变量； modules 以污染全局变量的方法来实现 api； library 和 modules 包含的文件基本相同，最大的不同是_export.js 这个文件： modules // core-js/modules/_exports.js var global = require('./_global'); var core = require('./_core'); var hide = require('./_hide'); var redefine = require('./_redefine'); var ctx = require('./_ctx'); var PROTOTYPE = 'prototype'; var $export = function (type, name, source) { var IS_FORCED = type & $export.F; var IS_GLOBAL = type & $export.G; var IS_STATIC = type & $export.S; var IS_PROTO = type & $export.P; var IS_BIND = type & $export.B; var target = IS_GLOBAL ? global : IS_STATIC ? global[name] || (global[name] = {}) : (global[name] || {})[PROTOTYPE]; var exports = IS_GLOBAL ? core : core[name] || (core[name] = {}); var expProto = exports[PROTOTYPE] || (exports[PROTOTYPE] = {}); var key, own, out, exp; if (IS_GLOBAL) source = name; for (key in source) { // contains in native own = !IS_FORCED && target && target[key] !== undefined; // export native or passed out = (own ? target : source)[key]; // bind timers to global for call from export context exp = IS_BIND && own ? ctx(out, global) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out; // extend global if (target) redefine(target, key, out, type & $export.U); // export if (exports[key] != out) hide(exports, key, exp); if (IS_PROTO && expProto[key] != out) expProto[key] = out; } }; global.core = core; // type bitmap $export.F = 1; // forced $export.G = 2; // global $export.S = 4; // static $export.P = 8; // proto $export.B = 16; // bind $export.W = 32; // wrap $export.U = 64; // safe $export.R = 128; // real proto method for `library` module.exports = $export; library // core-js/library/_exports.js var global = require('./_global'); var core = require('./_core'); var ctx = require('./_ctx'); var hide = require('./_hide'); var has = require('./_has'); var PROTOTYPE = 'prototype'; var $export = function (type, name, source) { var IS_FORCED = type & $export.F; var IS_GLOBAL = type & $export.G; var IS_STATIC = type & $export.S; var IS_PROTO = type & $export.P; var IS_BIND = type & $export.B; var IS_WRAP = type & $export.W; var exports = IS_GLOBAL ? core : core[name] || (core[name] = {}); var expProto = exports[PROTOTYPE]; var target = IS_GLOBAL ? global : IS_STATIC ? global[name] : (global[name] || {})[PROTOTYPE]; var key, own, out; if (IS_GLOBAL) source = name; for (key in source) { // contains in native own = !IS_FORCED && target && target[key] !== undefined; if (own && has(exports, key)) continue; // export native or passed out = own ? target[key] : source[key]; // prevent global pollution for namespaces exports[key] = IS_GLOBAL && typeof target[key] != 'function' ? source[key] // bind timers to global for call from export context : IS_BIND && own ? ctx(out, global) // wrap global constructors for prevent change them in library : IS_WRAP && target[key] == out ? (function (C) { var F = function (a, b, c) { if (this instanceof C) { switch (arguments.length) { case 0: return new C(); case 1: return new C(a); case 2: return new C(a, b); } return new C(a, b, c); } return C.apply(this, arguments); }; F[PROTOTYPE] = C[PROTOTYPE]; return F; // make static versions for prototype methods })(out) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out; // export proto methods to core.%CONSTRUCTOR%.methods.%NAME% if (IS_PROTO) { (exports.virtual || (exports.virtual = {}))[key] = out; // export proto methods to core.%CONSTRUCTOR%.prototype.%NAME% if (type & $export.R && expProto && !expProto[key]) hide(expProto, key, out); } } }; // type bitmap $export.F = 1; // forced $export.G = 2; // global $export.S = 4; // static $export.P = 8; // proto $export.B = 16; // bind $export.W = 32; // wrap $export.U = 64; // safe $export.R = 128; // real proto method for `library` module.exports = $export; 可以看出，library下的这个$export方法，会实现一个wrapper函数，防止污染全局变量。 例如对Promise的转译，@babel/polyfill和@babel/runtime-corejs2的转译方式差异如下： var p = new Promise(); // @babel/polyfill require(\"core-js/modules/es6.promise\"); var p = new Promise(); // @babel/runtime-corejs2 var _interopRequireDefault = require(\"@babel/runtime-corejs2/helpers/interopRequireDefault\"); var _promise = _interopRequireDefault(require(\"@babel/runtime-corejs2/core-js/promise\")); var a = new _promise.default(); 从上面这个例子可以看出，对于Promise这个api，@babel/polyfill引用了core-js/modules中的es6.promise.js文件，因为是对全局变量进行处理，所以赋值语句不用做处理；@babel/runtime-corejs2会生成一个局部变量_promise，然后把Promise都替换成_promise，这样就不会污染全局变量了。 综合上面的分析，得出结论： 如果是自己的应用： @babel/preset-env + @babel/polyfill 根据useBuiltIns参数确定如何使用@babel/polyfill，具体参数设置总结如下： useBuiltIns设置为entry比较不错，推荐使用。在js代码第一行import '@babel/polyfill'，或在webpack的入口entry中写入模块@babel/polyfill，会将browserslist环境不支持的所有垫片都导入； 能够覆盖到‘hello‘.includes(‘h‘)这种句法，足够安全且代码体积不是特别大！ useBuiltIns设置为usage。项目里不用主动import，会自动将代码里已使用到的、且browserslist环境不支持的垫片导入； 相对安全且打包的js体积不大，但是，通常我们转译都会排除node_modules/目录，如果使用到的第三方包有个别未做好ES6转译，有遇到bug的可能性，并且检测不到‘hello‘.includes(‘h‘)这种句法。 代码书写规范，且信任第三方包的时候，可以使用！ useBuiltIns设置为false比较不错。在js代码第一行import '@babel/polyfill'，或在webpack的入口entry中写入模块@babel/polyfill，会将@babel/polyfill整个包全部导入； 最安全，但打包体积会大一些，一般不选用。 需要安装的全部依赖： yarn add babel-loader @babel/core @babel/preset-env -D yarn add @babel/polyfill .babelrc配置文件 { \"presets\": [ [ \"@babel/preset-env\", { \"modules\": false, // 推荐 \"useBuiltIns\": \"entry\", // 推荐 \"corejs\": 2, // 新版本的@babel/polyfill包含了core-js@2和core-js@3版本，所以需要声明版本，否则webpack运行时会报warning，此处暂时使用core-js@2版本（末尾会附上@core-js@3怎么用） } ] ], \"plugins\": [] } 如果是开发第三方类库： @babel/preset-env + @babel/plugin-transform-runtime + @babel/runtime-corejs2。 另外，要注意自己使用的第三方依赖包，它们自身也可能存在兼容问题，如果有问题，一般在测试浏览器兼容问题时即可发现，这时，需要你手动从 core-js 引入需要的 polyfill。 因为，通常打包编译时，是不会处理 node_modules 目录的。 「或者，不处理 polyfill 的问题，提醒使用者自己按照 preset-env 的方式做好兼容处理也可以，某些第三方库就是这么做的。」 需要安装的全部依赖： yarn add babel-loader @babel/core @babel/preset-env @babel/plugin-transform-runtime -D yarn add @babel/runtime-corejs2 .babelrc配置文件 { \"presets\": [ [ \"@babel/preset-env\", { \"modules\": false, } ] ], \"plugins\": [ [ \"@babel/plugin-transform-runtime\", { \"corejs\": 2 // 推荐 } ] ] } 参考文档 babel polyfill 和 runtime 浅析 Babel + Webpack 配置前端项目 powered by GitbookLast modified time： 2021-04-23 15:03:41 "},"content/babel/proposal.html":{"url":"content/babel/proposal.html","title":"提案级别的插件","keywords":"","body":" babel 官方认为，把不稳定的 stage0-3 作为一种预设是不太合理的，@babel/preset-env、@babel/polyfill等只支持到stage-4级别，因此 babel 新版本废弃了 stage 预设，转而让用户自己选择使用哪个 proposal 特性的插件，这将带来更多的明确性（用户无须理解 stage，自己选的插件，自己便能明确的知道代码中可以使用哪个特性）。 所有建议特性的插件，都改变了命名规范，即类似 @babel/plugin-proposal-function-bind 这样的命名方式来表明这是个 proposal 阶段特性。 所以，处于建议阶段的特性，基本都已从@babel/preset-env、@babel/polyfill等包中被移除，需要自己去另外安装对应的 preset、plugin，（一般你能找到的名称里有 proposal 字样的包，需要自己在@babel/preset-env、@babel/plugin-transform-runtime以外做配置）。 各个级别当前可以选用的 proposal 插件大概如下（传送门）： { \"plugins\": [ // Stage 0 \"@babel/plugin-proposal-function-bind\", // Stage 1 \"@babel/plugin-proposal-export-default-from\", \"@babel/plugin-proposal-logical-assignment-operators\", [\"@babel/plugin-proposal-optional-chaining\", { \"loose\": false }], [\"@babel/plugin-proposal-pipeline-operator\", { \"proposal\": \"minimal\" }], [\"@babel/plugin-proposal-nullish-coalescing-operator\", { \"loose\": false }], \"@babel/plugin-proposal-do-expressions\", // Stage 2 [\"@babel/plugin-proposal-decorators\", { \"legacy\": true }], \"@babel/plugin-proposal-function-sent\", \"@babel/plugin-proposal-export-namespace-from\", \"@babel/plugin-proposal-numeric-separator\", \"@babel/plugin-proposal-throw-expressions\", // Stage 3 \"@babel/plugin-syntax-dynamic-import\", \"@babel/plugin-syntax-import-meta\", [\"@babel/plugin-proposal-class-properties\", { \"loose\": false }], \"@babel/plugin-proposal-json-strings\" ] } powered by GitbookLast modified time： 2021-04-23 15:03:41 "},"content/babel/decorators.html":{"url":"content/babel/decorators.html","title":"装饰器语法支持","keywords":"","body":" 安装依赖 yarn add @babel/plugin-proposal-decorators @babel/plugin-proposal-class-properties -D .babelrc 增加配置 { \"presets\": [], \"plugins\": [ [ \"@babel/plugin-proposal-decorators\", // @babel/plugin-proposal-decorators需要在@babel/plugin-proposal-class-properties之前 { \"legacy\": true // 推荐 } ], [ \"@babel/plugin-proposal-class-properties\", { \"loose\": true // babel编译时，对class的属性采用赋值表达式，而不是Object.defineProperty（更简洁） } ] ] } powered by GitbookLast modified time： 2021-04-23 15:03:41 "},"content/babel/import.html":{"url":"content/babel/import.html","title":"动态导入支持","keywords":"","body":" 安装依赖 yarn add @babel/plugin-syntax-dynamic-import -D .babelrc 文件增加配置 { \"presets\": [], \"plugins\": [ \"@babel/plugin-syntax-dynamic-import\", ] } powered by GitbookLast modified time： 2021-04-23 15:03:41 "},"content/babel/corejs3.html":{"url":"content/babel/corejs3.html","title":"corejs 3 的更新","keywords":"","body":" 以上是 core-js@2 的配置，而 core-js@3 的更新，带来了新的变化，@babel/polyfill 无法提供 core-js@2 向 core-js@3 过渡，所以现在有新的方案去替代@babel/polyfill，（需要 babel-loader 版本升级到 8.0.0 以上，@babel/core 版本升级到 7.4.0 及以上），详细可以阅读官方的几篇文档： 作者的官方阐述 Babel 7.4.0 版本的更新内容，及官方的升级建议 core-js@2 向 core-js@3 升级，官方的 Pull request @babel/preset-env 也因 core-js@3 的原因，需要配置 corejs 参数，否则 webpack 运行时会报 warning； @babel/polyfill 不必再安装，转而需要依靠core-js和regenerator-runtime（详细原因请看作者的阐述），替代方案用法如下： 安装依赖 yarn add babel-loader @babel/core @babel/preset-env -D yarn add core-js regenerator-runtime .babelrc 配置 { \"presets\": [ [ \"@babel/preset-env\", { \"modules\": false, // 对ES6的模块文件不做转化，以便使用tree shaking、sideEffects等 \"useBuiltIns\": \"entry\", // browserslist环境不支持的所有垫片都导入 // https://babeljs.io/docs/en/babel-preset-env#usebuiltins // https://github.com/zloirock/core-js/blob/master/docs/2019-03-19-core-js-3-babel-and-a-look-into-the-future.md \"corejs\": { \"version\": 3, // 使用core-js@3 // Babel 7.4 supports injecting proposals polyfills. By default, @babel/preset-env does not inject them, but you can opt-in using the proposals flag: corejs: { version: 3, proposals: true }. \"proposals\": true, } } ] ], \"plugins\": [] } js 代码里取代原先的import '@babel/polyfill'，做如下修改： import 'core-js/stable'; import 'regenerator-runtime/runtime'; 而@babel/plugin-transform-runtime，也随着 core-js@3 有更新： 安装依赖 yarn add babel-loader @babel/core @babel/preset-env @babel/plugin-transform-runtime -D yarn add @babel/runtime-corejs3 .babelrc 文件配置 { \"presets\": [ [ \"@babel/preset-env\", { \"modules\": false, } ] ], \"plugins\": [ [ \"@babel/plugin-transform-runtime\", { \"corejs\": { \"version\": 3, // Another notable change is the support of ECMAScript proposals. By default, @babel/plugin-transform-runtime does not inject polyfills for proposals and use entry points which do not include them but, exactly as you can do in @babel/preset-env, you can set the proposals flag to enable them: corejs: { version: 3, proposals: true }. \"proposals\": true }, \"useESModules\": true } ] ] } ‘hello‘.includes(‘h‘)这种句法，在使用 corejs@3 后，也可以被自动转译。 一些预设级别的特性默认情况下是不包含的（文档：https://babeljs.io/docs/en/v7-migration#remove-proposal-polyfills-in-babel-polyfill-https-githubcom-babel-babel-issues-8416）， 如果想要包含： import 'core-js/shim'; // included 推荐 这一篇对 Babel 的解读非常到位，强烈推荐。 https://mp.weixin.qq.com/s/B8XRsMg2uJrQTD5IFWOdlw powered by GitbookLast modified time： 2021-04-23 15:03:41 "},"content/style.html":{"url":"content/style.html","title":"CSS 样式的处理","keywords":"","body":"less、postcss 需要安装的依赖包 yarn add less less-loader css-loader style-loader postcss-loader postcss-preset-env postcss-import cssnano postcss-safe-parser mini-css-extract-plugin -D 过去版本的autoprefixer、postcss-cssnext已内置在postcss-preset-env内。 配置 默认会将 css 一起打包到 js 里，借助 mini-css-extract-plugin 将 css 分离出来并自动在生成的 html 中 link 引入（过去版本中的 extract-text-webpack-plugin 已不推荐使用）。 const MiniCssExtractPlugin = require('mini-css-extract-plugin') loader { test: /\\.(less|css)$/, use: [MiniCssExtractPlugin.loader, 'css-loader', 'postcss-loader', 'less-loader'], } // 在启用dev-server时，mini-css-extract-plugin插件不能使用contenthash给文件命名 => 所以本地起dev-server服务调试时，使用style-loader // USE_HMR是自定义的环境变量，意思是是否使用了热替换中间件 const styleLoader = process.env.USE_HMR ? 'style-loader' : MiniCssExtractPlugin.loader // 通过其他合适的方式判断是否为本地调试环境也一样，自由选择。 const styleLoader = process.env.BUILD_ENV === 'development' ? 'style-loader' : MiniCssExtractPlugin.loader { test: /\\.(less|css)$/, use: [styleLoader, 'css-loader', 'postcss-loader', 'less-loader'], }, plugin // 单独使用link标签加载css并设置路径，相对于output配置中的publickPath new MiniCssExtractPlugin({ filename: 'static/css/[name].[contenthash:7].css', // 注意这里使用的是contenthash，否则任意的js改动，打包时都会导致css的文件名也跟着变动。 chunkFilename: 'static/css/[name].[contenthash:7].css', }) PostCSS 本身不会对你的 CSS 做任何事情, 你需要安装一些 plugins（postcss GitHub 文档） 才能开始工作。 在 package.json 同级目录，新建 postcss.config.js 文件: module.exports = { // parser: 'sugarss', // 是一个以缩进为基础的语法，类似于 Sass 和 Stylus，https://github.com/postcss/sugarss plugins: { 'postcss-import': {}, 'postcss-preset-env': {}, 'cssnano': {}, 'postcss-flexbugs-fixes': {}, } } 常用的插件: cssnano —— 会压缩你的 CSS 文件来确保在开发环境中下载量尽可能的小 其它有用的插件: postcss-pxtorem —— px 单位自动转换 rem postcss-assets —— 插件用来处理图片和 SVG, 类似 url-load postcss-sprites —— 自动合成雪碧图，提供了细致的配置方法、插件去自定义控制（看上去略复杂） img-loader —— 自动压缩图片，参数控制压缩比率 postcss-font-magician —— 使用自定义字体时, 自动搞定@font-face 声明 Less 是预处理，而 PostCSS 是后处理，基本支持 less 等预处理器的功能，自动添加浏览器厂商前缀向前兼容，允许书写下一代 css 语法 ，可以在编译时去除冗余的 css 代码，PostCSS 声称比预处理器快 3-30 倍，因为 PostCSS，可能我们要放弃 less/sass/stylus 了。 powered by GitbookLast modified time： 2021-04-23 15:03:41 "},"content/media.html":{"url":"content/media.html","title":"图片、字体、多媒体等资源的处理","keywords":"","body":" css或js 中引入的图片、字体、多媒体等静态资源，统一使用 url-loader 处理。 配置了 url-loader 以后，webpack 编译时可以自动将小文件转成 base64 编码，减少网络请求。如果不需要将小文件转成 base64 ，也可以用 file-loader 替换 url-loader。 安装依赖包 url-loader 内部会自动调用 file-loader，所以仍然需要安装。 yarn add url-loader file-loader -D 添加配置 // 处理图片(file-loader来处理也可以，url-loader更适合图片) { test: /\\.(png|jpe?g|gif|svg)(\\?.*)?$/, loader: 'url-loader', options: { limit: 10000, name: 'static/assets/images/[name].[hash:7].[ext]', }, }, // 处理多媒体文件 { test: /\\.(mp4|webm|ogg|mp3|wav|flac|aac)(\\?.*)?$/, loader: 'url-loader', options: { limit: 10000, name: 'static/assets/media/[name].[hash:7].[ext]', }, }, // 处理字体文件 { test: /\\.(woff2?|eot|ttf|otf)(\\?.*)?$/, loader: 'url-loader', options: { limit: 10000, name: 'static/assets/fonts/[name].[hash:7].[ext]' } }, js中使用到静态资源，需要通过 import、require 导入再使用，才会被处理。 import img from 'xxx/xxx/123.jpg' 或 let img = require('xxx/xxx/123.jpg') 对于直接在 html 页面中通过标签引入的图片或其它静态资源，即使配置了 url-loader，webpack也不会去处理它们，可以使用 html-loader 处理。 安装依赖包 yarn add html-loader -D 添加配置 // html中引用的静态资源在这里处理,默认配置参数attrs=img:src,处理图片的src引用的资源. { test: /\\.html$/, loader: 'html-loader', options: { // 除了img的src,还可以继续配置处理更多html引入的资源(不能在页面直接写路径,又需要webpack处理怎么办?先require再js写入). attrs: ['img:src', 'img:data-src', 'audio:src'], minimize: false, removeComments: true, collapseWhitespace: false } } 静态资源的访问路径问题 经过上面的处理，静态资源处理基本没有问题了，webpack 编译时将会将文件打包到你指定的生成目录，但是不同位置的路径url会是一个问题。全部通过绝对路径访问即可，在 output 下的 publicPath 填上适当的 server 端头，来保证所有静态资源文件能被访问到，具体要根据服务器部署的目录结构来做修改。 output: { path: path.resolve(__dirname, 'dist'), // 输出目录的配置，模板、样式、脚本、图片等资源的路径配置都相对于它 publicPath: '/', // 模板、样式、脚本、图片等资源对应的server上的路径 } powered by GitbookLast modified time： 2021-04-23 15:03:41 "},"content/dev-server.html":{"url":"content/dev-server.html","title":"配置 dev-server","keywords":"","body":"webpack-dev-server 安装依赖包 yarn add webpack-dev-server -D 常用配置 devServer: { contentBase: path.join(__dirname, 'static'), // 告诉服务器从哪里提供内容(默认当前工作目录) openPage: 'views/index.html', // 指定默认启动浏览器时打开的页面 index: 'views/index.html', // 指定首页位置 watchContentBase: true, // contentBase下文件变动将reload页面(默认false) host: 'localhost', // 默认localhost,想外部可访问用'0.0.0.0' port: 8080, // 默认8080 inline: true, // 可以监控js变化 hot: true, // 热启动 open: true, // 启动时自动打开浏览器（指定打开chrome，open: 'Google Chrome'） compress: true, // 一切服务都启用gzip 压缩 disableHostCheck: true, // true：不进行host检查 quiet: false, https: false, clientLogLevel: 'none', stats: { // 设置控制台的提示信息 chunks: false, children: false, modules: false, entrypoints: false, // 是否输出入口信息 warnings: false, performance: false, // 是否输出webpack建议（如文件体积大小） }, historyApiFallback: { disableDotRule: true, }, watchOptions: { ignored: /node_modules/, // 略过node_modules目录 }, proxy: { // 接口代理（这段配置更推荐：写到package.json，再引入到这里） \"/api-dev\": { \"target\": \"http://api.test.xxx.com\", \"secure\": false, \"changeOrigin\": true, \"pathRewrite\": { // 将url上的某段重写（例如此处是将 api-dev 替换成了空） \"^/api-dev\": \"\" } } }, before(app) { }, } 根据目录结构的不同，contentBase、openPage 参数要配置合适的值，否则运行时应该不会立刻访问到你的首页; 同时要注意你的 publicPath，静态资源打包后生成的路径是一个需要思考的点，这与你的目录结构有关。 package.json 添加运行命令 \"scripts\": { \"dev\": \"cross-env BUILD_ENV=development webpack-dev-server --mode development --colors --profile\" } 不同操作系统传递参数的形式不一样，cross-env 可以抹平这个平台差异。 实用技巧： dev-server 的代码通常在内存中，但也可以写入硬盘，产出实体文件： { writeToDisk: true, } 通常可以用于代理映射文件调试，编译时会产出许多带 hash 的js 文件，不带 hash 的文件同样也是实时编译的。 有的时候，启动服务时，想要默认使用本地的 ip 地址打开： { disableHostCheck: true, // true：不进行host检查 // useLocalIp: true, // 建议不在这里配置 // host: '0.0.0.0', // 建议不在这里配置 } 同时还需要将 host 配置为 0.0.0.0，这个配置建议在 scripts 命令中追加，而非在配置中写死，否则将来不想要这种方式往回改折腾，取巧一点，配个新命令： \"dev-ip\": \"yarn run dev --host 0.0.0.0 --useLocalIp\", 有时启动的时候希望是指定的调试域名，例如：local.test.baidu.com： { open: true, public: 'local.test.baidu.com:8080', // 需要带上端口 port: 8080, } 同时需要将 127.0.0.1 修改为指定的 host，可以借助 iHost 等工具去修改，各个工具大同小异，格式如下： 127.0.0.1 local.test.baidu.com 服务启动后将自动打开 local.test.baidu.com:8080 访问 dev-server 调试时，启动 gzip 压缩： { compress: true, } 本地开发调试的时候，也许你还想要开启允许跨域： headers: { 'Access-Control-Allow-Origin': '*', }, powered by GitbookLast modified time： 2021-04-23 15:03:41 "},"content/alias.html":{"url":"content/alias.html","title":"模块配置别名、扩展名","keywords":"","body":"模块配置别名、扩展名 给模块配置扩展名，导入时即可省略文件后缀，webpack将自动完成查找。 给模块或目录配置别名，即可在导入时避免书写冗长的引入路径，如：import $ from 'utils/zepto.min'；某个自己写的通用插件，配置别名为xx后，即可：import xx from 'xx'。 示例代码： const paths = require('./paths') module.exports = { ... resolve: { // 配置模块扩展名 extensions: ['.js', '.json', '.css', '.less', '.art'], // 配置模块别名或目录别名 alias: { src: paths.appSrc, components: paths.appComponents, // 将路径放到path.js里统一管理，更加推荐 xx: path.resolve(__dirname, 'src/lib/xx.js'), // 给某个模块配置别名 }, }, ... } powered by GitbookLast modified time： 2021-04-23 15:03:41 "},"content/provide.html":{"url":"content/provide.html","title":"全局注入模块，省去到处导入","keywords":"","body":" 通常使用模块，我们需要先import、require该模块，例如：react，我们需要在每个react组件中都import一次，通过webpack.ProvidePlugin，我们可以省去这种重复劳动，不必在组件中单独导入。 module.exports = { ... plugins: [ // 大量需要使用到的模块，在此处一次性注入，避免到处import/require。 new webpack.ProvidePlugin({ React: 'react', Zepto: 'zepto', }), ], ... } powered by GitbookLast modified time： 2021-04-23 15:03:41 "},"content/define.html":{"url":"content/define.html","title":"注入应用的全局变量","keywords":"","body":"注入应用的全局变量 process.env是nodejs运行环境下的全局变量，在我们的应用代码（如src目录下的代码）中是无法直接读取到的，如果想要在应用代码中读取到process.env，或者如package.json中的数据，或其它nodejs环境中才有的变量，可以通过webpack.DefinePlugin将它们注入到应用中，将被声明为全局变量，直接读取即可。 如react脚手架，是以这种方式，将所有的process.env变量，全部注入到了应用代码中，所以使用react脚手架搭建的应用，可以直接通过process.env.读取到环境变量。 通常我们可以通过这种方式，去配置、读取系统的版本号；通过自己定义环境变量，注入到应用中，去区分编译环境。 示例代码： module.exports = { ... plugins: [ // 应用中需要的process.env变量，在此注入才能使用。 new webpack.DefinePlugin({ BUILD_ENV: JSON.stringify(process.env.BUILD_ENV), // 编译环境（development/test/production） }), ], ... } powered by GitbookLast modified time： 2021-04-23 15:03:41 "},"content/module.html":{"url":"content/module.html","title":"在 webpack 中引入未模块化的库","keywords":"","body":"如何在 webpack 中引入未模块化的库，如：Zepto script-loader 把我们指定的模块 JS 文件转成纯字符串，exports-loader 将需要的 js 对象 module.exports 导出，以支持 import 或 require 导入。 安装依赖包 yarn add script-loader exports-loader -D 配置 { test: require.resolve('zepto'), loader: 'exports-loader?window.Zepto!script-loader' } 以上是正常处理一个 \"可以 npm 安装，但又不符合 webpack 模块化规范\" 的库，例如其它库 XX，处理后可以直接 import xx from XX 后使用; 但是，zepto 有点特殊，默认 npm 安装的包或者从 github clone 的包，都是仅包含 5 个模块，其它如常用的 touch 模块是未包含的，想要正常使用还需做得更多。 怎样拿到一个包含更多模块的 zepto 包 ？ a) 打包出一个包含更多需要模块的 zepto 包 从 github clone 官方的包下来, 找到名为 make 的文件 ( 在 package.json 同级目录 ),， 用记事本打开，找到这一行 modules = (env['MODULES'] || 'zepto event ajax form ie').split(' ')，应该是在第 41 行，手动修改加入你想要引入的模块，然后保存; b) 在 make 文件同级目录 => 右键打开终端或 git bash => 敲 yarn add 安装 zepto 源码需要的 node 包 ( 这里你应当是已经已安装过 nodejs 了，如果没有，安装好后再做这一步 )，等待安装结束. c) 在刚才打开的 终端/git bash 敲命令 npm run-script dist，如果没有报错，你应该在这个打开的文件夹里可以看到生成了一个文件夹 dist，打开它，包含新模块的 zepto 包就在这了，Over ! 拿到新的 zepto 包后，建议放到自己的 src 下 lib 目录( 第三方工具包目录 )，不再通过 npm 的方式去安装和更新 zepto 了 ( 因为将来 npm update 后的 zepto 又将缺少模块，将来别人也会出现误操作 )；现在开始对这个放在 lib 目录下的 zepto.min.js 进行处理： 通过 script-loader、exports-loader 转成符合 webpack 模块化规范的包 { // # require.resolve()是nodejs用来查找模块位置的方法,返回模块的入口文件 test: require.resolve('./src/js/lib/zepto.min.js'), loader: 'exports-loader?window.Zepto!script-loader' } 给模块配置别名 resolve: { alias: { 'zepto': path.resolve(__dirname, './src/js/lib/zepto.min.js') } } 自动加载模块，不再到处 import 或 require new webpack.ProvidePlugin({ $: 'zepto', Zepto: 'zepto', }) 大功告成，现在使用 zepto 跟你使用 jquery 或其它 node 包是一样的开发体验了！ 以上，演示的是对于一个第三方库( 不能 npm 安装，也不符合 webpack 模块规范 )，如何去处理，达到和正常 npm 安装一样的开发体验，仅就 zepto 来说，npm 库有符合 webpack 规范的不同版本 (zepto-webpack，或 zepto-modules)，有需要可以试试。平时意图使用某个包，先去NPM 官网搜一搜比较好。 powered by GitbookLast modified time： 2021-04-23 15:03:41 "},"content/prune.html":{"url":"content/prune.html","title":"externals 打包时排除某些模块","keywords":"","body":"externals 打包时排除某些模块 webpack提供的 externals，可以在打包时将该模块移除（即不打包到最终的代码里），以减小包的体积，被移除的该模块独立通过 CDN 在页面通过 script 标签引入。 仅做实际应用的介绍，更深入的解读推荐读这一篇：webpack externals 深入理解。 以 jQuery 为例，演示最常见的用途。 我们的代码中是这样书写的 jQuery 代码： import $ from 'jquery' $('.my-element').animate(/* ... */) 在 webpack 的编译配置里添加如下配置： module.exports = { ... output: { ... }, externals: { // webpack 默认是通过全局变量来提供 jQuery，这里的 jQuery 等价于 root jQuery // https://webpack.js.org/configuration/externals/#externals jquery: \"jQuery\" }, ... } 在运行打包以后，应用中的 jquery 包即被替换为全局变量 window.jQuery。 打包后的结果大概是下面的样子。 ({ 0: function(...) { var jQuery = require(1); /* ... */ }, 1: function(...) { // 很明显这里是把window.jQuery赋值给了module.exports // 因此我们便可以使用require来引入了。 module.exports = jQuery; }, /* ... */ }); 使用你打包产出的代码，需要预先准备 jQuery 环境，即：script 标签引入。 不引入会怎样？当然就会报错：$ 对象找不到啦！ 总结 某些知名的库，如：jQuery、React、Vue、Echarts 等，都有提供 CDN 的方式访问，就可以通过 externals 来缩减自己的项目代码体积。 这样使用的意义： 从 CDN 访问速度会更快一些; 版本长期不变动，用户仅第一次访问需要下载，后续访问直接从本地读取，速度能提升; 当然，如果你已经通过拆分 vendor 包，来做了基础包的缓存工作，那么就不是十分需要这么做了。通常，更建议将项目依赖的多个库，集中打包到 vendor，保持长期不变动，充分发挥浏览器缓存的作用。 应用中的某个包，在编译时排除，并指定别的包替换它。 uni-app 的小程序项目，实际使用到了这个功能，截取作为示例供参考。 externals: [ function(context, request, callback) { // 版本不同，此处的函数参数与 babel 官网上的参数形式有区别 /** * 1、在 uni-app 里，使用各家小程序的原生组件时，编译工具的处理方式是：将对应目录下的原生组件直接 copy 过去； * 2、因为这样的机制，衍生了一个问题： * a.类似 @xmly/lite-login_wx 这个微信小程序原生组件，它提供的 request 等模块，本身是期望开发者发送请求时使用，解决携带喜马拉雅登录 cookie 的问题，但 uni-app 的编译机制， * b.会导致 copy 过去的微信小程序原生组件是一个实例，而 import { request } from '@xmly/lite-login_wx/lib/index' 导入的模块，在 uni-app 编译时，被再次编译，在构建产物里是另一个实例， * c.进而导致了 bug（request 带不上 cookie！） * 3、为了解决以上问题，通过 externals 略过导入 request 模块不打包到产物里，并修改引用路径，问题得到解决！ */ if (/^@xmly\\/lite-login_wx\\/lib\\/index$/.test(request)){ // 这里是将 @xmly/lite-login_wx 这个包，替换成了本地（编译后的代码）的另一个路径下的包 return callback(null, 'commonjs ' + '../wxcomponents/@xmly/lite-login_wx/lib/index') } callback() } ], powered by GitbookLast modified time： 2021-04-23 15:03:41 "},"content/library.html":{"url":"content/library.html","title":"打包 js 库时的应用","keywords":"","body":"webpack打包js库 通常打包js库会选择 rollup，但是 webpack 同样可以做到，如果是需要对 css、图片等有较多应用的 js 库，webpack 会有更多优势。 配置 module.exports = { ... entry: { sdk: 'xxxxxxx.js', }, output: { ... library: '[name]', // 被挂载到全局对象（window、global）上的变量名称 libraryTarget: 'umd', // 模块规范，umd 包含全部模块规范 libraryExport: 'default', // 导出的对象，默认是 default umdNamedDefine: true, // 会对 UMD 的构建过程中的 AMD 模块进行命名，否则就使用匿名的 define }, ... } umd —— 打包出所有环境都可以使用的包 代码里导出 export default { a: xxxx, b: xxxx, c: xxxx, } build打包后的js，将支持import、requrie导入，script标签引入，可以通过window.sdk使用等： // import import { a, b, c } from '........js' // require const anything = require('........js') // window window.sdk window.sdk.a // node global.sdk global.sdk.a 参考文档： 怎样打包一个library？ 一次打包暴露多个库 powered by GitbookLast modified time： 2021-04-23 15:03:41 "},"content/banner.html":{"url":"content/banner.html","title":"在打包的文件头部添加 Banner 信息","keywords":"","body":"在打包的文件头部添加 Banner 信息 在打包文件时，某些场景可能需要在文件顶部添加描述信息，例如：版本、版权、作者、发布时间以及其它相关说明等，通常在打包 JS 库时比较常见，官方提供了 webpack.BannerPlugin 实现此功能。 const webpack = require('webpack') const { version, author, homepage } = require('../package') ... module.exports = { ... plugins: [ // webpack.BannerPlugin 添加在这里会无效，因为生成的注释描述会被 TerserPlugin 或其它压缩插件清掉 ], optimization: { minimizer: [ new TerserPlugin({ ... }), new OptimizeCSSAssetsPlugin({ ... }), // 注意位置，必须放在 TerserPlugin 后面，否则生成的注释描述会被 TerserPlugin 或其它压缩插件清掉 new webpack.BannerPlugin({ entryOnly: true, // 是否仅在入口包中输出 banner 信息 banner: () => { return `xxxxx v${version}` + `\\n` + `Author: ${author}` + `\\n` + `Documentation: ${homepage}` + `\\n` + `Date: ${new Date()}` } }), ] } } ... 效果示例： powered by GitbookLast modified time： 2021-04-23 15:03:41 "},"content/node-server.html":{"url":"content/node-server.html","title":"配置 node express 服务","keywords":"","body":"配置 node express 服务 某些时候可能希望本地访问打包后的资源，可以配置一个 node express 服务完成。当然，你也可以通过它代理接口，mock数据（虽然不必如此）。 新建 prod.server.js 文件，放到 package.json 同级目录 let express = require('express') let compression = require('compression') let app = express() let port = 9898 app.use(compression()) app.use(express.static('./static/')) module.exports = app.listen(port, function(err) { if (err) { console.log(err) return } console.log('Listening at http://localhost:' + port + '\\n') }) 运行命令 node prod.server.js 访问路径 localhost:9898/views/ powered by GitbookLast modified time： 2021-04-23 15:03:41 "},"content/http-server.html":{"url":"content/http-server.html","title":"配置 http-server","keywords":"","body":" 比自己配置一个 node express 服务更简洁的方式，去访问打包后的资源，可以使用 http-server 。 安装依赖 yarn add http-server -D package.json 配置命令 \"scripts\": { \"http-server\": \"http-server dist\" } 访问路径 localhost:8080 或 http://127.0.0.1:8080 powered by GitbookLast modified time： 2021-04-23 15:03:41 "},"content/eslint.html":{"url":"content/eslint.html","title":"集成 eslint","keywords":"","body":" 安装依赖 yarn add eslint eslint-loader eslint-friendly-formatter babel-eslint -D eslint-friendly-formatter，指定终端中输出eslint提示信息的格式。 增加配置 { test: /\\.js$/, enforce: 'pre', loader: 'eslint-loader', include: [paths.appSrc], exclude: [ /node_modules/, ], options: { formatter: require('eslint-friendly-formatter'), }, }, package.json文件同级增加文件.eslintrc.js module.exports = { \"root\": true, \"parserOptions\": { \"sourceType\": \"module\", }, \"parser\": \"babel-eslint\", // eslint未支持的js新特性先进行转换 \"env\": { \"browser\": true, \"es6\": true, \"node\": true, \"shared-node-browser\": true, \"commonjs\": true, }, \"globals\": { // 设置全局变量（false：不允许重写；） \"BUILD_ENV\": false, }, \"extends\": \"eslint:recommended\", // 使用官方推荐规则，使用其他规则，需要先install，再指定。 \"rules\": { // 定义检查规则 } } 配置项含义： root 限定配置文件的使用范围 parser 指定eslint的解析器 parserOptions 设置解析器选项 extends 指定eslint规范 plugins 引用第三方的插件 env 指定代码运行的宿主环境 rules 启用额外的规则或覆盖默认的规则 globals 声明在代码中的自定义全局变量 ESLint官方的rules列表 如果有需要跳过检查的文件/文件夹，有两种途径可以实现： 新建.eslintignore文件 /node_modules 直接在文件、代码里加标识，详细请看：官方文档的忽略规则 参考文档 webpack引入eslint详解 babel-eslint powered by GitbookLast modified time： 2021-04-23 15:03:41 "},"content/optimize.html":{"url":"content/optimize.html","title":"常见性能优化","keywords":"","body":"常见性能优化 speed-measure-webpack-plugin 分析 webpack 编译过程中，各个 plugin、loader 等耗费的时间 示例 const SpeedMeasurePlugin = require('speed-measure-webpack-plugin') const timestamp = require('time-stamp') const smp = new SpeedMeasurePlugin({ // 默认通过 console.log 在终端直接输出 // 如果配置此项，可以将内容输出在指定目录（目录需先手动创建好）下的指定文件（文件会自动创建） outputTarget: path.resolve(__dirname, `../log`, `performance_${timestamp('YYYYMMDD_HH:mm:ss')}.log`) }) webpackConfig = smp.wrap(webpackConfig) // webpackConfig 是你原先的 webpack 配置 webpack-monitor 分析打包产物。 示例 const WebpackMonitor = require('webpack-monitor') const timestamp = require('time-stamp') const { version } = require('../package') ... plugins: [ // http://webpackmonitor.com/ new WebpackMonitor({ target: `../monitor/stats_v${version}_${timestamp('YYYYMMDD_HH:mm:ss')}.json`, // 输出的JSON统计文件的路径（相对于构建目录） launch: false, // 是否启动分析面板 // capture: true, // 如果当前版本与先前版本不同，则捕获当前版本的统计信息 // port: 3030, // 启动时为Webpack Monitor仪表板提供服务的端口 }), ], ... webpack-bundle-analyzer 分析打包产物 示例 const { BundleAnalyzerPlugin } = require('webpack-bundle-analyzer') ... plugins: [ // https://www.npmjs.com/package/webpack-bundle-analyzer // 演示直接输出 html 文件形式 new BundleAnalyzerPlugin({ analyzerMode: 'static', // html 文件方式输出编译分析 openAnalyzer: false, reportFilename: path.resolve(__dirname, '..', `analyzer/index.html`), }), ] ... 使用happypack来优化，多进程运行编译，参考文档： webpack 优化之 HappyPack 实战 happypack 原理解析 使用cache-loader缓存编译结果 DllPlugin拆分基础包 powered by GitbookLast modified time： 2021-04-23 15:03:41 "},"content/patch-package.html":{"url":"content/patch-package.html","title":"自动修改 node_moduels 的包源码","keywords":"","body":"自动修改 node_moduels 源码 已迁移至 ☞ https://blog.eleven.net.cn/2020/06/11/nodejs/patch-package/ powered by GitbookLast modified time： 2021-04-23 15:03:41 "},"content/circular.html":{"url":"content/circular.html","title":"模块间循环引用问题","keywords":"","body":"模块间循环引用问题 有时候可能会遇见这样的场景：模块A引用了模块B里的func1方法，而模块B又引用了模块A里的func2方法。 类似上面的场景，或者其它更复杂的如：A 引用 B，B 引用 C，C 又引用了 A，在不经意间可能会遇到一些诡异问题，如：明明代码没问题，却读不到导入的模块...... 为了更好地避免这样的问题，可以使用 circular-dependency-plugin 插件来做循环引用的检测: 基本用法如下，复制、粘贴即可生效： // webpack.config.js const CircularDependencyPlugin = require('circular-dependency-plugin') module.exports = { plugins: [ new CircularDependencyPlugin({ // exclude detection of files based on a RegExp exclude: /node_modules/, // include specific files based on a RegExp include: /src/, // add errors to webpack instead of warnings failOnError: true, // allow import cycles that include an asyncronous import, // e.g. via import(/* webpackMode: \"weak\" */ './file.js') allowAsyncCycles: false, // set the current working directory for displaying module paths cwd: process.cwd(), }) ] } 检测到问题时，会看到如下图的编译提示： 如何解决循环引用的问题？将被循环引用到的模块提取放到另外的模块，打破这个循环即可！ 参考文档 webpack 与循环引用 JavaScript 模块的循环加载 powered by GitbookLast modified time： 2021-04-23 15:03:41 "},"content/inline.html":{"url":"content/inline.html","title":"内联 js/css 等资源","keywords":"","body":"内联 js/css 等资源 在某些特殊场景，你可能希望将 js/css 等资源，直接通过 style/script 标签的形式插入到 html 中。 比较常见的如： runtime 代码，因为体积极小，单独成文件只会增加 http 请求的时间，不如直接放置到 html 页面上。 在移动端，如果使用 REM 方案，这段 js 的计算代码，应当尽可能早的加载、执行，尽早的确定 html 根标签的 font-size。 在 webpack 打包的过程中，想要实现，大概可以有以下 3 种方式。 react-dev-utils/InlineChunkHtmlPlugin React 官方在 CRA 脚手架中提供了这种方式，去将指定的 chunk 内联到 html。 使用方式： const HtmlWebpackPlugin = require('html-webpack-plugin') const InlineChunkHtmlPlugin = require('react-dev-utils/InlineChunkHtmlPlugin') module.exports = { ... plugins: [ // 数组中指定正则表达式去匹配 new InlineChunkHtmlPlugin(HtmlWebpackPlugin, [/runtime~.+[.]js/]), ], ... } 在数组中指定的正则表达式，用于匹配 webpack 打包后的产物，命中的将会被内联到 html，注意需要依赖 html-webpack-plugin。 如果是非 CRA 创建的项目，可以使用社区的这个包 inline-chunk-html-plugin 。 inline-source-webpack-plugin 此 plugin 适用 webpack4 以上，如果是低版本 webpack，可以使用 inline-resource-plugin 。 使用方式： 在 webpack 的配置文件中添加插件配置，注意需要依赖 html-webpack-plugin 。 // webpack.config.js const HtmlWebpackPlugin = require('html-webpack-plugin') const InlineSourceWebpackPlugin = require('inline-source-webpack-plugin') module.exports = { ... plugins: [ new HtmlWebpackPlugin({ ... }), new InlineSourceWebpackPlugin({ compress: true, rootpath: './src', // 可以指定 plugin 处理时的根目录（从项目的根目录开始） noAssetMatch: 'warn' }), ], ... } 在 html 文件中添加 script 标签，指定 inline、inline-asset、inline-asset-delete 等属性。 内联项目中的某个文件，或者内联 webpack 的编译产物文件，两者使用方式略有区别，请看下方注释。 test hello world! raw-loader raw-loader 一般性的使用是：将某模块文件转成字符串输出。同时，我们也可以用来将某文件内联到 html。 使用方式： 安装过 raw-loader 以后，在 html 文件中添加如下 script 标签。依赖的是 html-webpack-plugin 来识别该语法（如果 html-webpack-plugin 插件是比较旧的版本，语法需要有点区别）。 test 编写 require 语句时，可以指定多个 loader 去处理指定的文件，例如上方即指定了 babel-loader 处理。 raw-loader 默认生成使用 ES 模块语法的 JS 模块，需要注意一下，可能会导致使用出错或不生效。 参考文档：webpack使用raw-loader内联静态资源失效 inline-source 「暂时没有时间测试，做个记录先。」 总结 综合上面几种方法，都能实现，各有一点区别。 react-dev-utils/InlineChunkHtmlPlugin 在 CRA 创建的项目里使用，处理 runtime 代码很合适；只能将打包的产物文件内联。 inline-source-webpack-plugin 既可以将某个文件内联，也可以将打包的产物内联；但是，直接内联某个文件，该文件不会经过 babel 转译，要注意这个问题。 raw-loader 只能将某个文件内联，不能将打包的产物内联；内联的某个文件可以经过 babel 转译。 powered by GitbookLast modified time： 2021-04-23 15:03:41 "},"content/reference.html":{"url":"content/reference.html","title":"参考文档","keywords":"","body":"参考文档 webpack 中文文档 —— 直接阅读它非常有用，百度出来的教程 99%都是管中窥豹，只见一斑，会形成误导（不要问我是怎么知道的 -_-）。 NPM 中文文档 基于 webpack 的前端工程化开发之多页站点篇（一） 基于 webpack 的前端工程化开发之多页站点篇（二） webpack 在前端项目中使用心得一二 webpack4配置详解之逐行分析 手摸手，带你用合理的姿势使用 webpack4（上） 手摸手，带你用合理的姿势使用 webpack4（下） 一文读懂 babel7 的配置文件加载逻辑 babel polyfill 和 runtime 浅析 powered by GitbookLast modified time： 2021-04-23 15:03:41 "}}